<style>
	body {
		font-family: Arial, sans-serif;

		--dark: #777;
		--medium: #b5b5b5;
		--light: #e5e5e5;
		--off-white: #f5f5f5;

		--button-hover-bg: var(--off-white);
		--button-active-bg: var(--light);
		--button-selected-fg: white;
		--button-selected-bg: var(--medium);
		--header-fg: var(--dark);
		--numbers-fg: var(--medium);
		--vertical-scroll-bg: var(--off-white);
		--vertical-scroll-handle-bg: var(--medium);

		--text-span-selected-fg: #fff;
		--text-span-selected-bg: #333;
		--text-span-ends-at-fg: #fff;
		--text-span-ends-at-bg: #b5b5b5;
		--text-span-marked-fg: #07b;
		--text-span-marked-bg: #e5f5ff;
	}

	.page {
		display: flex;
		height: 100%;
	}

	button {
		background: none;
		border: 1px solid;
	}

	button:hover {
		background: var(--button-hover-bg);
		cursor: pointer;
	}

	button:active {
		background: var(--button-active-bg);
	}

	button.selected {
		color: var(--button-selected-fg);
		background: var(--button-selected-bg);
	}

	select {
		width: 100%;
	}

	.file-pane {
		flex: 0;
		flex-basis: 300px;
		display: flex;
		flex-direction: column;
		overflow: hidden;
		padding: 5px 10px;
		border: 1px solid;
		border-right: none;
	}

	.header {
		margin: 15px 0 5px;
		font-size: 12px;
		color: var(--header-fg);
	}

	.section {
		margin: 5px 0 5px;
	}

	.row {
		margin: 5px 0;
	}

	#select-dir-button {
		width: 100%;
		text-align: start;
	}

	#index-name-input {
		width: 80px;
	}

	#index-whitelist-input {
		width: 140px;
	}

	#file-selector {
		width: 100%;
	}

	#results {
		flex: 1;
		overflow: auto;
	}

	#results button {
		display: block;
		white-space: nowrap;
		border: none;
	}

	.text-pane {
		flex: 1;
		display: flex;
		overflow: hidden;
		user-select: none;
		font-size: 16px;
		border: 1px solid;
		align-items: stretch;
	}

	#numbers {
		margin: 0;
		padding: 5px 10px 5px 5px;
		position: sticky;
		left: 0;
		border-right: 1px solid;
		color: var(--numbers-fg);
	}

	#text {
		margin: 5px;
		flex: 1;
		overflow: hidden;
	}

	#text span.selected {
		color: var(--text-span-selected-fg);
		background: var(--text-span-selected-bg);
	}

	#text span.ends-at {
		color: var(--text-span-ends-at-fg);
		background: var(--text-span-ends-at-bg);
	}

	#text span.marked {
		color: var(--text-span-marked-fg);
		background: var(--text-span-marked-bg);
	}

	#vertical-scroll {
		width: 9px;
		background: var(--vertical-scroll-bg);
	}

	#vertical-scroll-handle {
		pointer-events: none;
		position: relative;
		background: var(--vertical-scroll-handle-bg);
	}
</style>

<div class="page">
	<div class="file-pane">
		<div class="section">
			<div class="row">
				<button id="select-dir-button">Select dir</button>
			</div>
		</div>
		<div class="section">
			<p class="header">Index list</p>
			<div class="row">
				<select id="index-select"></select>
			</div>
			<div class="row">
				<button id="load-index-button">Load</button>
				<button id="remove-index-button">Remove</button>
			</div>
		</div>
		<div class="section">
			<p class="header">Add index</p>
			<div class="row">
				<input id="index-name-input" placeholder="Name">
				<input id="index-whitelist-input" placeholder="Whitelist">
				<button id="add-index-button">Add</button>
			</div>
		</div>
		<div class="section">
			<p class="header">Select file</p>
			<div class="row">
				<input id="file-selector" placeholder="Search">
			</div>
		</div>
		<div id="results" class="section"></div>
	</div>

	<div class="text-pane">
		<pre id="numbers"></pre>
		<pre id="text"><span id="empty-sizing-char"> </span></pre>
		<div id="vertical-scroll">
			<div id="vertical-scroll-handle"></div>
		</div>
		<!--todo horiz scroll bar-->
	</div>
</div>

<script type="module">
	import * as idb from 'https://unpkg.com/idb?module';

	const $ = document.querySelector.bind(document);
	const sleep = (ms = 0) => new Promise(resolve => setTimeout(resolve, ms));

	class Debouncer {
		constructor(duration) {
			this.duration = duration;
			this.lastTime = 0;
		}

		request(handler) {
			let id = this.id = {};
			setTimeout(() => {
				if (id !== this.id)
					return;
				this.lastTime = Date.now();
				handler();
			}, this.duration - Date.now() + this.lastTime);
		}
	}

	let dbPromise = idb.openDB('xEditor-c5', 1, {
		upgrade: db => {
			db.createObjectStore('index');
			db.createObjectStore('text');
		}
	});

	class FileIndex {
		constructor(files) {
			this.files = files;
			this.files.forEach(file =>
				file.pathJoint = file.pathJoint || file.path
					.map(p => p.match(/[a-z]+|[A-Z][a-z]*|\d+|./g).join(' '))
					.join(' / '));
		}

		static listIndices(db) {
			return db.getAllKeys('index');
		}

		store(db, name) {
			db.put('index', this.files.map(({path}) => ({path})), name);
		}

		static async restore(db, name) {
			return new FileIndex(await db.get('index', name));
		}

		static remove(db, name) {
			return db.delete('index', name);
		}

		static readDirEntry(handle, timeout = 500) {
			return new Promise(async (resolve, reject) => {
				setTimeout(() => reject('timeout'), timeout);
				let entries = [];
				for await (const entry of await handle.getEntries())
					entries.push(entry);
				resolve(entries);
			});
		}

		static async readDirEntryRetry(handle, timeout = 500, tries = 5, waitBetweenTries = 500) {
			while (tries--) {
				try {
					return await FileIndex.readDirEntry(handle, timeout);
				} catch (e) {
					let msg = `Failed to read ${handle.name}, ${tries} tries remaining.`;
					console.warn(msg);
					await sleep(waitBetweenTries);
					if (!tries) {
						throw msg;
					}
				}
			}
		}

		static async read(entryHandle, whitelistDirs = []) {
			let start = Date.now();
			let files = [];
			let pending = [{path: [], handle: entryHandle, failed: 0}];

			while (pending.length) {
				let {path, handle, failed} = pending.pop();
				try {
					(await FileIndex.readDirEntryRetry(handle)).forEach(entry => {
						if (entry.isFile)
							files.push({path: path.concat(entry.name), handle: entry});
						else if (path.length || !whitelistDirs.length || whitelistDirs.includes(entry.name))
							pending.push({path: path.concat(entry.name), handle: entry, failed: 0});
					});
					if (path.length < 3)
						console.info(`Read ${files.length}, pending ${pending.length}, queued ${path}.`);
				} catch (e) {
					failed++;
					console.error(`Skipped ${path},${handle.name}. Failure ${failed} of 3 - ${e}`);
					if (failed < 3)
						pending.push({path, handle, failed: failed});
				}
			}
			console.info(`Done, read ${files.length} files in ${(Date.now() - start) / 1000} seconds.`);
			return files;
		}
	}

	class FilePaneController {
		constructor() {
			this.loadIndexSelect();

			$('#select-dir-button').addEventListener('click', async () => {
				this.entryHandle = await chooseFileSystemEntries({type: 'openDirectory'});
				$('#select-dir-button').textContent = this.entryHandle.name;
			});

			$('#load-index-button').addEventListener('click', async () =>
				this.setIndex(await FileIndex.restore(await dbPromise, $('#index-select').value)));

			$('#remove-index-button').addEventListener('click', async () => {
				await FileIndex.remove(await dbPromise, $('#index-select').value);
				this.loadIndexSelect();
			});

			$('#add-index-button').addEventListener('click', async () => this.onAddIndexClick());

			$('#file-selector').addEventListener('input', () => this.updateResults());
			$('#file-selector').addEventListener('keydown', e => {
				// todo allow cursor selection
				if (e.key === 'Enter')
					$('#results').firstChild.click();
			});
		}

		async loadIndexSelect() {
			while ($('#index-select').firstChild)
				$('#index-select').removeChild($('#index-select').firstChild);
			let indices = await FileIndex.listIndices(await dbPromise);
			indices.forEach(index => {
				let option = document.createElement('option');
				option.textContent = index;
				$('#index-select').appendChild(option);
			});
		}

		setIndex(index) {
			this.index = index;
			this.updateResults();
		}

		async onAddIndexClick() {
			if (!this.entryHandle)
				return;
			let whitelist = $('#index-whitelist-input').value.split(/[, ]/g).filter(a => a);
			let files = await FileIndex.read(this.entryHandle, whitelist);
			this.setIndex(new FileIndex(files));
			let indexName = `${$('#index-name-input').value} @ ${this.entryHandle.name} (${whitelist.join(', ')})`;
			this.index.store(await dbPromise, indexName);
			this.loadIndexSelect();
		}

		async updateResults() {
			// todo include exact matches from non indexed paths
			if (!this.index)
				return;

			let input = $('#file-selector').value;
			let files = this.index.files;
			const regexSpecial = '.*+?^${}()|[]\\';
			let filteredPaths = [], filterSize = 60;
			if (input) {
				let inputRegexString = [...input.replace(/\s/g, '')]
					.map(c => regexSpecial.includes(c) ? '\\' + c : c)
					.join('(.* )?');
				let inputRegex = new RegExp(inputRegexString, 'i');
				files.forEach(file => {
					if (filteredPaths.length < filterSize && inputRegex.test(file.pathJoint))
						filteredPaths.push({path: file.path});
				});
			} else
				filteredPaths = files.slice(0, filterSize);

			while ($('#results').firstChild)
				$('#results').removeChild($('#results').firstChild);
			filteredPaths.forEach(({path}) => {
				let fileEl = document.createElement('button');
				fileEl.textContent = path.join(' / ');
				$('#results').appendChild(fileEl);
				fileEl.addEventListener('click', () => {
					[...$('#results').children].forEach(fileEl => fileEl.classList.remove('selected'));
					fileEl.classList.add('selected');
					emitFileOpen(path);
				})
			});
		}

		async readFile(path) {
			if (!this.entryHandle)
				return;
			let file = this.index.files.find(({path: pathI}) => pathI.every((p, i) => p === path[i]));
			file.handle = file.handle || await path.reduce(async (handle, p, i, a) =>
				i === a.length - 1 ? (await handle).getFile(p) : (await handle).getDirectory(p), this.entryHandle);
			return (await file.handle.getFile()).text();
		}
	}

	const cursorMovement = {
		CHAR: {},
		ROW: {},
		LARGE_ROW: {},
		SUB_WORD: {},
		WORD: {},
		LINE: {},
		TEXT: {},
		GROW: {},
		GROW_FULL: {},
	};

	class Cursor {
		constructor(start = 0, end = start) {
			if (start <= end)
				this.set(start, end);
			else
				this.set(end, start, true);
		}

		set(left = 0, right = left, reverse = false) {
			this.left = left;
			this.right = right;
			this.reverse = reverse;
		}

		get clone() {
			return new Cursor(this.start, this.end);
		}

		// shifts this according to removal of cursor
		shiftByRemovalOf(cursor) {
			this.left = cursor.shiftPointForRemoval(this.left);
			this.right = cursor.shiftPointForRemoval(this.right);
		}

		// shifts point according to removal of this
		shiftPointForRemoval(point) {
			return point - Math.max(Math.min(point, this.right) - this.left, 0);
		}

		// shifts this according to insertion
		shiftByInsertionOf(insertionPoint, insertionLength) {
			if (insertionPoint <= this.left)
				this.left += insertionLength;
			if (insertionPoint <= this.right)
				this.right += insertionLength;
		}

		get empty() {
			return this.left === this.right;
		}

		get start() {
			return this.reverse ? this.right : this.left;
		}

		get end() {
			return this.reverse ? this.left : this.right;
		}

		set end(end) {
			let start = this.start;
			this.reverse = end < start;
			this.left = this.reverse ? end : start;
			this.right = this.reverse ? start : end;
		}

		includes(point) {
			return point >= this.left && point < this.right;
		}

		// if this and cursor overlap, merge into this and return true
		mergeWith(cursor) {
			if (!(this.empty && this.left >= cursor.left && this.left <= cursor.right ||
				cursor.empty && cursor.left >= this.left && cursor.left <= this.right) &&
				(this.left >= cursor.right || cursor.left >= this.right))
				return false;
			this.set(Math.min(this.left, cursor.left), Math.max(this.right, cursor.right));
			return true;
		}
	}

	class Text {
		constructor(text = '', history = [{text, cursor: new Cursor()}]) {
			this.text = text;
			this.history = history;
			this.historyIndex = history.length - 1;
			this.cursors = this.clonedCursors(history[this.historyIndex].cursors);
			// todo cursors not merged correctly
		}

		store(db, key = '___scratch___') {
			let history = this.history.map(({text, cursors}) => ({text, cursors: cursors.map(({start, end}) => ({start, end}))}));
			db.put('text', {text: this.text, history}, key);
		}

		static async restore(db, key = '___scratch___') {
			let {text, history} = await db.get('text', key) || {};
			history = history.map(({text, cursors}) => ({text, cursors: cursors.map(({start, end}) => new Cursor(start, end))}));
			return new Text(text, history);
		}

		static clamp(value, min, max) {
			return Math.min(Math.max(value, min), max);
		}

		static cleanText(text) {
			return text.replace(/\r\n?/g, '\n').replace(/\t/g, '  ');
		}

		pointToXY(point) {
			let preText = this.text.substring(0, point);
			let y = (preText.match(/\n/g) || []).length;
			let x = preText.match(/.*$/)[0].length;
			return {x, y};
		}

		xyToPoint(x, y) {
			return y >= 0 ? this.text.match(new RegExp(`(.*\\n?){0,${y}}.{0,${x}}`))[0].length : 0;
		}

		mouseXyToPoint(x, y) {
			let {startContainer: textNode, startOffset: offset} = document.caretRangeFromPoint(x - 3, y); // todo compute 3 from char width / 2
			let point = textNode.parentNode['data-split'] + Text.clamp(offset, 0, textNode.textContent.length - 1);
			return Text.clamp(point, 0, this.text.length);
		}

		// base text editing methods

		getTextAt(cursor) {
			return this.text.substring(cursor.left, cursor.right);
		}

		removeTextAt(cursor) {
			this.text = this.text.substring(0, cursor.left) + this.text.substring(cursor.right);
			this.cursors.forEach(cursorI => cursorI.shiftByRemovalOf(cursor));
		}

		insertTextAt(text, point) {
			text = Text.cleanText(text);
			this.text = this.text.substring(0, point) + text + this.text.substring(point);
			this.cursors.forEach(cursorI => cursorI.shiftByInsertionOf(point, text.length));
		}

		// text editing methods

		replaceSelections(text) {
			this.replaceSelectionsMulti(this.cursors.map(() => text));
		}

		replaceSelectionsMulti(texts) {
			this.cursors.forEach((cursor, i) => {
				this.removeTextAt(cursor.clone);
				this.insertTextAt(texts[i] || '', cursor.end);
			});
			this.mergeCursors();
			this.commitText();
		}

		replaceAll(text) {
			this.setCursor(this.text.length);
			this.removeTextAt(new Cursor(0, this.text.length));
			this.insertTextAt(text, 0);
			this.commitText();
			this.setCursor(text.length);
		}

		deleteSelections(right, word, line, allLine) {
			// todo migrate parameter to cursorMovement enum
			this.cursors.forEach(cursor => {
				let delIndices = [cursor.left, cursor.right];
				let i = right + 0;
				if (allLine) {
					delIndices[0] = this.findNextLinePoint(delIndices[0], false);
					delIndices[1] = this.findNextLinePoint(delIndices[1], true) + 1;
				} else if (!cursor.empty)
					;
				else if (line)
					delIndices[i] = this.findNextLinePoint(delIndices[i], right);
				else if (word)
					delIndices[i] = this.findNextWordPoint(delIndices[i], right);
				else
					delIndices[i] = Text.clamp(delIndices[i] + right * 2 - 1, 0, this.text.length);
				this.removeTextAt(new Cursor(delIndices[0], delIndices[1]));
			});
			this.mergeCursors();
			this.commitText();
		}

		toggleCommentSelections(inline) {
			this.cursors.forEach(cursor => {
				if (inline) {
					// todo inline commenting
				} else {
					// todo if multiple lines selected, comment/uncomment all
					let prefixPoint = this.findNextLineTextPoint(cursor.left, false);
					let prefixCursor = new Cursor(prefixPoint, prefixPoint + 3);
					if (this.getTextAt(prefixCursor) === '// ')
						this.removeTextAt(prefixCursor);
					else
						this.insertTextAt('// ', prefixPoint);
				}
			});
			this.mergeCursors();
			this.commitText();
		}

		// selection methods

		isSelected(left, right, all) {
			for (let i = left; i < right; i++) {
				let some = this.cursors.some(cursor => cursor.includes(i));
				if (all && !some)
					return false;
				else if (!all && some)
					return true;
			}
			return all;
		}

		selectNone() {
			this.cursors = [new Cursor(this.cursors[0].end)];
			this.commitCursor();
		}

		selectAll() {
			this.cursors = [new Cursor(0, this.text.length)];
			this.commitCursor();
		}

		selectNextOccurrence(right, move = false) {
			let cursor = this.lastCursor;
			if (cursor.empty)
				return this.replaceLastCursor(...this.wordGrowCursorBoundaries(cursor, false));
			let text = this.getTextAt(cursor);
			let next = this.findNextUnselectedOccurrenceWrapPoint(text, cursor.left, right);
			if (next === -1)
				return;
			if (move)
				this.replaceLastCursor(next, next + text.length);
			else
				this.addCursor(next, next + text.length);
		}

		selectAllOccurrences() {
			let cursor = this.lastCursor.empty ? new Cursor(...this.wordGrowCursorBoundaries(cursor, false)) : this.lastCursor;
			let text = this.getTextAt(cursor);
			let indices = this.findAllOccurrencePoints(text, cursor.left);
			this.addCursors(indices, text.length);
		}

		// cursor methods

		get lastCursor() {
			return this.cursors[this.cursors.length - 1];
		}

		setCursor(start, end = start) {
			this.cursors = [new Cursor(start, end)];
			this.commitCursor();
		}

		addCursor(start, end = start) {
			this.cursors.push(new Cursor(start, end));
			this.mergeCursors();
			this.commitCursor();
		}

		addCursors(starts, length) {
			this.cursors = [...this.cursors, ...starts.map(start => new Cursor(start, start + length))];
			this.mergeCursors();
			this.commitCursor();
		}

		removeLastCursor() {
			if (this.cursors.length === 1)
				return;
			this.cursors.pop();
			this.commitCursor();
		}

		updateLastCursor(end) {
			this.lastCursor.end = end;
			this.mergeCursors();
			this.commitCursor();
		}

		replaceLastCursor(start, end = start) {
			this.cursors.pop();
			this.cursors.push(new Cursor(start, end));
			this.mergeCursors();
			this.commitCursor();
		}

		moveCursors(right, movement, select) {
			this.cursors.forEach(cursor => {
				let newStart = -1;
				let newEnd = cursor.end;
				let d = right * 2 - 1;

				switch (movement) {
					case cursorMovement.CHAR:
						if (cursor.empty || select)
							newEnd = Text.clamp(newEnd + d, 0, this.text.length);
						else
							newEnd = right ? cursor.right : cursor.left;
						break;
					case cursorMovement.ROW: {
						let {x, y} = this.pointToXY(newEnd);
						newEnd = this.xyToPoint(x, y + d);
						break;
					}
					case cursorMovement.LARGE_ROW: {
						let {x, y} = this.pointToXY(newEnd);
						newEnd = this.xyToPoint(x, y + d * 50);
						break;
					}
					case cursorMovement.SUB_WORD:
						newEnd = this.findNextSubWordPoint(newEnd, right);
						break;
					case cursorMovement.WORD:
						newEnd = this.findNextWordPoint(newEnd, right);
						break;
					case cursorMovement.LINE:
						newEnd = this.findNextLinePoint(newEnd, right, false);
						break;
					case cursorMovement.TEXT:
						newEnd = right ? this.text.length : 0;
						break;
					case cursorMovement.GROW:
						if (right)
							newEnd = cursor.start;
						else {
							let tempNewEnd;
							[newStart, tempNewEnd] = this.wordGrowCursorBoundaries(cursor);
							if (tempNewEnd === newEnd && newStart === cursor.left) {
								newStart = this.findNextLinePoint(cursor.left, false);
								newEnd = this.findNextLinePoint(cursor.right, true);
							} else if (tempNewEnd > newEnd)
								newEnd = tempNewEnd;
						}
						break;
					case cursorMovement.GROW_FULL:
						newStart = this.findNextLinePoint(cursor.left, false);
						newEnd = this.findNextLinePoint(cursor.right, true);
						break;
				}

				if (newStart !== -1)
					cursor.set(newStart, newEnd);
				else if (select)
					cursor.end = newEnd;
				else
					cursor.set(newEnd);
			});
			this.mergeCursors();
			this.commitCursor();
		}

		mergeCursors() {
			this.cursors = this.cursors.filter((cursor, i) =>
				!this.cursors.some((cursorNewer, j) =>
					j > i && cursorNewer.mergeWith(cursor)));
		}

		// cursor find point methods

		findNextSubWordPoint(point, right) {
			return this.findNextPoint(point, right, /(([A-Z]?[a-z0-9]+_?|[A-Z0-9]+_?|(.)\3*)[^\S\n]*|\n)/);
		}

		findNextWordPoint(point, right, excludeNewLine = false, trailingWhitespace = true) {
			let regex = new RegExp(`((\\w+|(.)\\3*)${trailingWhitespace ? '[^\\S\\n]*' : ''}|\\n)`);
			return this.findNextPoint(point, right, regex, excludeNewLine);
		}

		findNextLinePoint(point, right) {
			return this.findNextPoint(point, right, /.*/);
		}

		findNextLineTextPoint(point, right) {
			return this.findNextPoint(point, right, /.*\s*/);
		}

		findNextPoint(point, right, breakRegex, excludeNewLine = false) {
			let subText = right ? this.text.substring(point) : this.text.substring(0, point);
			let regex = new RegExp(breakRegex.source + (right ? '' : '$'));
			let match = (subText.match(regex) || [''])[0];
			if (excludeNewLine && match === '\n')
				return point;
			return point + (match.length + (point > this.text.length ? 1 : 0)) * (right ? 1 : -1);
		}

		findNextUnselectedOccurrenceWrapPoint(text, point, right) {
			let next = point;
			while (true) {
				next = right ? this.text.indexOf(text, next + 1) : this.text.lastIndexOf(text, next - 1);
				if (next === -1) {
					if (!right)
						next = this.text.length;
					continue;
				}
				if (next === point)
					return -1;
				else if (!this.isSelected(next, next + text.length, true))
					return next;
			}
		}

		findAllOccurrencePoints(text, point = -1) {
			let indices = [];
			let next = point;
			while (true) {
				next = this.text.indexOf(text, next + 1);
				if (next === -1)
					continue;
				if (next === point)
					return indices;
				indices.push(next);
			}
		}

		wordGrowCursorBoundaries(cursor, trailingWhitespace = true) {
			let start = this.findNextWordPoint(cursor.start + 1, false, trailingWhitespace);
			let end = this.findNextWordPoint(start, true, true, trailingWhitespace);
			return [start, end];
		}

		// clipboard methods

		reorderedCursors() {
			return this.clonedCursors().sort((c1, c2) => c1.left - c2.left);
		}

		copy(preserveOrdering) {
			if (this.cursors.every(cursor => cursor.empty))
				this.moveCursors(false, cursorMovement.GROW_FULL, true);
			let cursors = preserveOrdering ? this.cursors : this.reorderedCursors();
			let texts = cursors.map(cursor => this.getTextAt(cursor));
			this.lastClipboard = texts;
			navigator.clipboard.writeText(texts.join('\n'));
		}

		cut(preserveOrdering) {
			this.copy(preserveOrdering);
			this.deleteSelections(false, false, false, false);
		}

		async paste(preserveOrdering) {
			let text = Text.cleanText(await navigator.clipboard.readText());
			let texts = text.split('\n');
			if (this.cursors.length === 1 || texts.length === 1)
				this.replaceSelections(text);
			else {
				if (this.lastClipboard && this.lastClipboard.length !== 1 && text === this.lastClipboard.join('\n'))
					texts = this.lastClipboard;
				if (!preserveOrdering)
					this.cursors = this.reorderedCursors();
				this.replaceSelectionsMulti(texts);
			}
		}

		// history methods

		clonedCursors(cursors = this.cursors) {
			return cursors.map(cursor => cursor.clone);
		}

		commitText() {
			if (!this.history[this.historyIndex].text)
				this.historyIndex++;
			this.history = this.history.slice(0, this.historyIndex);
			this.history[this.historyIndex] = {
				text: this.text,
				cursors: this.clonedCursors(),
			};
		}

		commitCursor() {
			this.history = this.history.slice(0, this.historyIndex + 1);
			this.history[++this.historyIndex] = {cursors: this.clonedCursors()};
		}

		restoreHistory(index) {
			this.text = this.history.slice(0, index + 1).reverse().find(({text}) => text !== undefined).text;
			this.cursors = this.clonedCursors(this.history[index].cursors);
		}

		nextHistory(redo) {
			return {index: this.historyIndex + redo * 2 - 1, textChanged: !this.history[this.historyIndex + redo] || this.history[this.historyIndex + redo].text};
		}

		undo(cursor, redo) {
			let next = this.nextHistory(redo);
			if (!this.history[next.index])
				return;
			if (!cursor) {
				if (next.textChanged)
					this.historyIndex = next.index;
				else
					do {
						this.historyIndex = next.index;
						next = this.nextHistory(redo)
					} while (!next.textChanged);
			} else if (!next.textChanged)
				this.historyIndex = next.index;
			else
				return;
			this.restoreHistory(this.historyIndex);
		}

		// render methods
		// todo move render functions to separate or controller class

		initRender() {
			({width: this.charWidth, height: this.charHeight} = $('#empty-sizing-char').getBoundingClientRect());
			this.scrollX = 0;
			this.scrollY = 0;
		}

		get scrollWidth() {
			return parseInt($('#text').getBoundingClientRect().width / this.charWidth);
		}

		get scrollHeight() {
			return parseInt($('#text').getBoundingClientRect().height / this.charHeight);
		}

		get scrollXMax() {
			return Math.max(...this.text.split('\n').map(line => line.length));
		}

		get scrollYMax() {
			return (this.text.match(/\n/g) || []).length;
		}

		scrollBy(dx, dy) {
			this.scrollX = Text.clamp(this.scrollX + dx, 0, this.scrollXMax);
			this.scrollY = Text.clamp(this.scrollY + dy, 0, this.scrollYMax);
		}

		scrollToRatio(rx, ry) {
			// rx & ry are expected to be [0, 1). Scrolls to center.
			this.scrollY = Text.clamp(parseInt(rx * this.scrollXMax - this.scrollwidth / 2), 0, this.scrollXMax);
			this.scrollY = Text.clamp(parseInt(ry * this.scrollYMax - this.scrollHeight / 2), 0, this.scrollYMax);
		}

		scrollToLastCursor() {
			let padding = 1;
			let {x, y} = this.pointToXY(this.lastCursor.end);
			this.scrollY = Text.clamp(this.scrollY, y - this.scrollHeight + 1 + padding, Math.max(y - padding, 0));
			this.scrollX = Text.clamp(this.scrollX, x - this.scrollWidth + 1 + padding, Math.max(x - padding, 0));
		}

		async render() {
			// todo render scrollbars
			while ($('#text').firstChild)
				$('#text').removeChild($('#text').firstChild);

			let maskStart = this.xyToPoint(0, this.scrollY);
			let maskEnd = this.xyToPoint(0, this.scrollY + this.scrollHeight) + 1;

			let cursorSplits = this.cursors.flatMap(cursor => [cursor.left, cursor.right, cursor.end + 1]);
			let markedSplits = this.cursors
				.map(cursor => this.getTextAt(cursor).trim() || this.getTextAt(new Cursor(...this.wordGrowCursorBoundaries(cursor, false))).trim())
				.filter(text => text)
				.flatMap(text => {
					let splits = [], i;
					while ((i = this.text.indexOf(text, i + 1)) >= 0) {
						if (i < maskEnd && i + text.length > maskStart)
							splits.push(i);
					}
					return splits.map(split => [split, text.length]);
				});
			let lineSplits = [maskStart], i = maskStart - 1;
			while ((i = this.text.indexOf('\n', i + 1)) >= 0 && i < maskEnd)
				lineSplits.push(i + 1);
			let splits = [...cursorSplits, ...markedSplits.flatMap(([split, length]) => [split, split + length]), ...lineSplits]
				.filter((split, i, a) => a.indexOf(split) === i)
				.sort((s1, s2) => s1 - s2);
			if (splits[0] !== 0)
				splits.unshift(0);
			let paddedText = this.text + ' ';

			let j = 0;
			for (let i = 0; i < lineSplits.length; i++) {
				let lineDiv = document.createElement('div');
				$('#text').appendChild(lineDiv);
				let lineSplit = lineSplits[i];
				let nextLineSplit = lineSplits[i + 1] || this.text.length + 1;
				let scrollXRemaining = this.scrollX;
				for (; j < splits.length && splits[j] < nextLineSplit; j++) {
					let split = Text.clamp(splits[j], maskStart, maskEnd);
					let nextSplit = Text.clamp(splits[j + 1] || this.text.length + 1, maskStart, maskEnd);
					if (split === nextSplit)
						continue;
					if (nextSplit - split <= scrollXRemaining) {
						scrollXRemaining -= nextSplit - split;
						continue;
					}
					split += scrollXRemaining;
					scrollXRemaining = 0;
					let text = paddedText.substring(split, nextSplit).replace(/\n/g, ' ');
					let span = this.renderSpan(text, split, nextSplit, markedSplits);
					lineDiv.appendChild(span);
				}
				let newLineSpan = document.createElement('span');
				newLineSpan.textContent = ' ';
				newLineSpan['data-split'] = nextLineSplit - 1;
				lineDiv.appendChild(newLineSpan);
			}

			$('#numbers').textContent = [...Array(Math.min(this.scrollHeight, this.scrollYMax - this.scrollY + 1))].map((_, i) => this.scrollY + i + 1).join('\n');

			$('#vertical-scroll-handle').style.height = `${this.scrollHeight / (this.scrollYMax + 1) * 100}%`;
			$('#vertical-scroll-handle').style.top = `${this.scrollY / (this.scrollYMax + 1) * 100}%`;
		}

		renderSpan(text, start, end, markedSplits) {
			let span = document.createElement('span');
			span.textContent = text;
			span['data-split'] = start;
			if (this.isSelected(start, end, false))
				span.classList.add('selected');
			else if (this.cursors.some(cursor => cursor.end === start))
				span.classList.add('ends-at');
			else if (markedSplits.some(([markedSplit, length]) => start >= markedSplit && start < markedSplit + length))
				span.classList.add('marked');
			return span;
		}
	}

	class TextPaneController {
		constructor() {
			dbPromise.then(async db => {
				// init
				this.text = await Text.restore(db);
				this.text.initRender();
				this.text.render();

				// key text & cursor
				document.addEventListener('keydown', e => this.onKeyDown(e));

				// mouse cursor
				$('#text').addEventListener('mousedown', e => this.onMouseDown(e)); // todo support .text-pane and #numbers clicks.
				$('#text').addEventListener('mousemove', e => this.onMouseMove(e));

				// scrolling
				this.scrollWheelEX = 0;
				this.scrollWheelEY = 0;
				this.scrollWheelDistance = 50;
				this.verticalScrollDebouncer = new Debouncer(10);
				$('.text-pane').addEventListener('wheel', e => this.onWheel(e));
				$('#vertical-scroll').addEventListener('mousedown', e => {
					this.verticalScrollDragging = true;
					this.onVerticalScrollBar(e);
				});
				document.addEventListener('mouseup', () => this.verticalScrollDragging = false);
				document.addEventListener('mousemove', e => {
					if (this.verticalScrollDragging)
						this.onVerticalScrollBar(e)
				});
			});
		}

		async onKeyDown(e) {
			if (e.target !== $('body'))
				return;

			const homeEndArrowCursorMovement =
				[cursorMovement.LINE, cursorMovement.TEXT, cursorMovement.LINE, cursorMovement.TEXT];
			const horizArrowCursorMovement =
				[cursorMovement.CHAR, cursorMovement.WORD, cursorMovement.LINE, cursorMovement.TEXT];
			const vertArrowCursorMovement =
				[cursorMovement.ROW, cursorMovement.GROW, cursorMovement.LARGE_ROW, cursorMovement.GROW];

			let modifierIndex = e.ctrlKey + e.altKey * 2;
			let noop = false;

			switch (e.key.toLowerCase()) {
				case 'enter':
					this.text.replaceSelections('\n');
					break;
				case 'tab':
					this.text.replaceSelections('\t');
					e.preventDefault();
					break;
				case 'home':
					this.text.moveCursors(false, homeEndArrowCursorMovement[modifierIndex], e.shiftKey);
					e.preventDefault();
					break;
				case 'end':
					this.text.moveCursors(true, homeEndArrowCursorMovement[modifierIndex], e.shiftKey);
					e.preventDefault();
					break;
				case 'arrowleft':
					this.text.moveCursors(false, horizArrowCursorMovement[modifierIndex], e.shiftKey);
					e.preventDefault();
					break;
				case 'arrowright':
					this.text.moveCursors(true, horizArrowCursorMovement[modifierIndex], e.shiftKey);
					e.preventDefault();
					break;
				case 'arrowup':
					e.preventDefault();
					this.text.moveCursors(false, vertArrowCursorMovement[modifierIndex], e.shiftKey);
					break;
				case 'arrowdown':
					this.text.moveCursors(true, vertArrowCursorMovement[modifierIndex], e.shiftKey);
					e.preventDefault();
					break;
				case ';':
				case ':':
					if (e.ctrlKey)
						this.text.moveCursors(false, cursorMovement.SUB_WORD, e.shiftKey);
					break;
				case "'":
				case '"':
					if (e.ctrlKey)
						this.text.moveCursors(true, cursorMovement.SUB_WORD, e.shiftKey);
					break;
				case 'delete':
					this.text.deleteSelections(true, e.ctrlKey, e.shiftKey, e.altKey);
					break;
				case 'backspace':
					this.text.deleteSelections(false, e.ctrlKey, e.shiftKey, e.altKey);
					break;
				case '/':
				case '?':
					if (e.ctrlKey)
						this.text.toggleCommentSelections(e.shiftKey);
					break;
				case 'f':
					// todo
					break;
				case 'g':
					if (e.ctrlKey || e.altKey) {
						if (e.shiftKey)
							this.text.removeLastCursor();
						else if (e.ctrlKey && e.altKey)
							this.text.selectAllOccurrences();
						else
							this.text.selectNextOccurrence(!e.altKey);
						e.preventDefault();
					}
					break;
				case 'h':
					if (e.ctrlKey) {
						this.text.selectNextOccurrence(!e.shiftKey, true);
						e.preventDefault()
					}
					break;
				case 'escape':
					this.text.selectNone();
					break;
				case 'a':
					if (e.ctrlKey) {
						this.text.selectAll();
						e.preventDefault();
					}
					break;
				case 'c':
					if (e.ctrlKey || e.altKey) {
						this.text.copy(e.altKey);
					}
					break;
				case 'x':
					if (e.ctrlKey || e.altKey) {
						this.text.cut(e.altKey);
					}
					break;
				case 'v':
					if (e.ctrlKey || e.altKey) {
						await this.text.paste(e.altKey);
					}
					break;
				case 'z':
					if (e.ctrlKey || e.altKey)
						this.text.undo(e.altKey, e.shiftKey);
					break;
				case ' ':
					e.preventDefault();
					break;
				default:
					noop = true;
					if (e.key.length !== 1)
						console.log(e.key, e.ctrlKey, e.shiftKey, e.altKey);
			}
			if (e.key.length === 1 && !e.ctrlKey && !e.altKey)
				this.text.replaceSelections(e.key);
			else if (noop)
				return;

			this.text.scrollToLastCursor();
			this.text.render();
			this.text.store(await dbPromise);
		}

		onMouseDown(e) {
			let now = Date.now();
			if (now - this.lastMouseDown < 300)
				this.text.moveCursors(false, cursorMovement.GROW, false); // todo only grow last cursor
			else {
				let point = this.text.mouseXyToPoint(e.x, e.y);
				if (Number.isNaN(point))
					return;
				if (e.ctrlKey)
					this.text.addCursor(point);
				else if (e.shiftKey)
					this.text.updateLastCursor(point);
				else
					this.text.setCursor(point);
			}
			this.lastMouseDown = now;
			this.text.scrollToLastCursor();
			this.text.render();
			// todo alt to block cursor
			// todo ctrl to add (or remove) cursor
			// todo on ctrl+alt, add (or remove) block cursor
		}

		onMouseMove(e) {
			if (!e.buttons || this.verticalScrollDragging)
				return;
			let point = this.text.mouseXyToPoint(e.x, e.y);
			if (point === this.lastMousePoint)
				return;
			this.lastMousePoint = point;
			this.text.updateLastCursor(point);
			this.text.scrollToLastCursor();
			this.text.render();
		}

		onWheel(e) {
			e.preventDefault();
			this.scrollWheelEX += e.deltaX;
			this.scrollWheelEY += e.deltaY;
			let dx = parseInt(this.scrollWheelEX / this.scrollWheelDistance);
			let dy = parseInt(this.scrollWheelEY / this.scrollWheelDistance);
			if (!dx && !dy)
				return;
			this.text.scrollBy(dx, dy);
			this.text.render();
			this.scrollWheelEX = this.scrollWheelEX % this.scrollWheelDistance;
			this.scrollWheelEY = this.scrollWheelEY % this.scrollWheelDistance;
		}

		onVerticalScrollBar(e) {
			if (e.buttons)
				this.verticalScrollDebouncer.request(() => {
					let {top, height} = $('#vertical-scroll').getBoundingClientRect();
					this.text.scrollToRatio(0, (e.clientY - top) / height);
					this.text.render();
				});
		}

		async setText(text) {
			this.text.replaceAll(text);
			this.text.scrollToLastCursor();
			this.text.render();
			this.text.store(await dbPromise);
		}
	}

	let filePaneController = new FilePaneController();
	let textPaneController = new TextPaneController();

	// todo use proper event emitting after we convert to custom elements
	let emitFileOpen = async path => {
		let fileText = await filePaneController.readFile(path);
		if (fileText !== undefined)
			textPaneController.setText(fileText);
	};

	// TODO

	// file deletion, creation, save
	// multitab files

	// highlight selected line

	// remove cursors on click

	// c-f find
	// c-r replace

	// c-g select next
	// c-s-g remove last-next selection
	// c-a-g select all
	// a-g select prev
	// a-s-g remove last-prev selection
	// c-h goto next
	// c-s-h goto previous

	// search by regex and whole word and case sensitive

	// tab to indent / unindent, ctrl tab to clone indentation form above line
	// m matching paren
	// on paren, add closing paren. wrap selected text

	// move lines up down
	// delete, duplicate, uppercase toggle
	// c-s-up/down -> move line up/down

	// prev/next edit location

	// autocomplete

	// alt shift arrows to create cursors

	// zoom in / out / default

	// display line, column, selection numbers.
	// goto line number

	// tabs and files

	// home/end to toggle between to post-whitespace and pre-whitespace,
	// arrows to not move cursor when have selection

	// a-,/. -> prev / next edit location,
	// c-,/. -> prev / next cursor location

	// snapshots and diff comparisons

	// DONE

	// typing
	// multi selection
	// merging overlapping cursors
	// mouse drag select
	// mouse single, double, triple click
	// highlight occurrences of selected text

	// del/backspace -> char
	// c-del/backspace -> word
	// s-del/backspace -> line end
	// a-del/backspace -> entire line

	// c-a
	// escape

	// c-/

	// c-x/c/v -> copy, cut, paste.
	// a-x/c/v -> copy, cut, paste with reordered cursors
	// copy/cut entire lines if nothing selected.
	// copy/cut/paste support multiline

	// left/right -> char
	// c-left/right -> word left/right
	// a-left/right -> line start/end
	// c-a-left/right -> text start/end
	// home/end -> line start/end
	// c-up/down -> grow/shrink
	// up/down -> row
	// c-home/end -> text start/end
	// c-;/' -> sub word

	// c-z -> undo
	// c-s-z -> redo
	// a-z or c-a-z -> undo cursor
	// a-s-z or c-a-s-z -> redo cursor
</script>
