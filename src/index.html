<style>
	#container {
		display: flex;
		height: 100%;
		overflow-y: auto;
		user-select: none;
		font-size: 16px;
		align-items: flex-start;
		outline: 1px solid;
		margin: 0;
	}

	#numbers, #text {
		margin: 0;
		padding: 5px;
	}

	#numbers {
		padding-right: 10px;
		position: sticky;
		left: 0;
		background: white;
		border-right: 1px solid;
	}

	#text {
		flex: 1;
	}

	span.selected {
		color: #fff;
		background: #333;
	}

	span.ends-at {
		color: #fff;
		background: #b5b5b5;
	}

	span.marked {
		color: #07b;
		background: #e5f5ff;
	}
</style>

<div id="container">
	<pre id="numbers"></pre>
	<pre id="text"></pre>
</div>

<script>
	const $ = document.querySelector.bind(document);

	const cleanText = text => text.replace(/\r\n?/g, '\n');
	const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

	const cursorMovement = {
		CHAR: {},
		ROW: {},
		LARGE_ROW: {},
		SUB_WORD: {},
		WORD: {},
		LINE: {},
		TEXT: {},
		GROW: {},
		GROW_FULL: {},
	};

	class Cursor {
		constructor(start = 0, end = start) {
			if (start <= end)
				this.set(start, end);
			else
				this.set(end, start, true);
		}

		set(left = 0, right = left, reverse = false) {
			this.left = left;
			this.right = right;
			this.reverse = reverse;
		}

		get clone() {
			return new Cursor(this.start, this.end);
		}

		// shifts this according to removal of cursor
		shiftByRemovalOf(cursor) {
			this.left = cursor.shiftPointForRemoval(this.left);
			this.right = cursor.shiftPointForRemoval(this.right);
		}

		// shifts point according to removal of this
		shiftPointForRemoval(point) {
			return point - Math.max(Math.min(point, this.right) - this.left, 0);
		}

		// shifts this according to insertion
		shiftByInsertionOf(insertionPoint, insertionLength) {
			if (insertionPoint <= this.left)
				this.left += insertionLength;
			if (insertionPoint <= this.right)
				this.right += insertionLength;
		}

		get empty() {
			return this.left === this.right;
		}

		get start() {
			return this.reverse ? this.right : this.left;
		}

		get end() {
			return this.reverse ? this.left : this.right;
		}

		set end(end) {
			let start = this.start;
			this.reverse = end < start;
			this.left = this.reverse ? end : start;
			this.right = this.reverse ? start : end;
		}

		includes(point) {
			return point >= this.left && point < this.right;
		}

		// if this and cursor overlap, merge and return true
		mergeWith(cursor) {
			if (this.left >= cursor.right || cursor.left >= this.right)
				return false;
			this.set(Math.min(this.left, cursor.left), Math.max(this.right, cursor.right));
			return true;
		}
	}

	class Text {
		constructor(text = '') {
			this.text = text;
			this.cursors = [new Cursor()];
			this.history = [{text, cursors: this.clonedCursors()}];
			this.historyIndex = 0;
		}

		static restore() {
			return new Text(
				localStorage.getItem('text') || '');
		}

		save() {
			localStorage.setItem('text', this.text);
		}

		pointToXY(point) {
			let preText = this.text.substring(0, point);
			let y = (preText.match(/\n/g) || []).length;
			let x = preText.match(/.*$/)[0].length;
			return {x, y};
		}

		xyToPoint(x, y) {
			return y >= 0 ? this.text.match(new RegExp(`(.*\\n?){0,${y}}.{0,${x}}`))[0].length : 0;
		}

		mouseXyToPoint(x, y) {
			let {startContainer: textNode, startOffset: offset} = document.caretRangeFromPoint(x, y);
			let point = textNode.parentNode['data-split'] + offset - (textNode.textContent.slice(0, offset + 1).match(/ \n/g) || []).length;
			return clamp(point, 0, this.text.length);
		}

		// base text editing methods

		getTextAt(cursor) {
			return this.text.substring(cursor.left, cursor.right);
		}

		removeTextAt(cursor) {
			this.text = this.text.substring(0, cursor.left) + this.text.substring(cursor.right);
			this.cursors.forEach(cursorI => cursorI.shiftByRemovalOf(cursor));
		}

		insertTextAt(text, point) {
			text = cleanText(text);
			this.text = this.text.substring(0, point) + text + this.text.substring(point);
			this.cursors.forEach(cursorI => cursorI.shiftByInsertionOf(point, text.length));
		}

		// text editing methods

		replaceSelections(text) {
			this.replaceSelectionsMulti(this.cursors.map(() => text));
		}

		replaceSelectionsMulti(texts) {
			this.cursors.forEach((cursor, i) => {
				this.removeTextAt(cursor.clone);
				this.insertTextAt(texts[i] || '', cursor.end);
			});
			this.mergeCursors();
			this.commitText();
		}

		deleteSelections(right, word, line, allLine) {
			// todo migrate parameter to cursorMovement enum
			this.cursors.forEach(cursor => {
				let delIndices = [cursor.left, cursor.right];
				let i = right + 0;
				if (allLine) {
					delIndices[0] = this.findNextLinePoint(delIndices[0], false);
					delIndices[1] = this.findNextLinePoint(delIndices[1], true) + 1;
				} else if (!cursor.empty)
					;
				else if (line)
					delIndices[i] = this.findNextLinePoint(delIndices[i], right);
				else if (word)
					delIndices[i] = this.findNextWordPoint(delIndices[i], right);
				else
					delIndices[i] = clamp(delIndices[i] + right * 2 - 1, 0, this.text.length);
				this.removeTextAt(new Cursor(delIndices[0], delIndices[1]));
			});
			this.mergeCursors();
			this.commitText();
		}

		toggleCommentSelections(inline) {
			this.cursors.forEach(cursor => {
				if (inline) {
					// todo inline commenting
				} else {
					// todo if multiple lines selected, comment/uncomment all
					let prefixPoint = this.findNextLineTextPoint(cursor.left, false);
					let prefixCursor = new Cursor(prefixPoint, prefixPoint + 3);
					if (this.getTextAt(prefixCursor) === '// ')
						this.removeTextAt(prefixCursor);
					else
						this.insertTextAt('// ', prefixPoint);
				}
			});
			this.mergeCursors();
			this.commitText();
		}

		// selection methods

		isSelected(left, right = left + 1) {
			for (let i = left; i < right; i++)
				if (!this.cursors.some(cursor => cursor.includes(i)))
					return false;
			return true;
		}

		selectNone() {
			this.cursors = [new Cursor(this.cursors[0].end)];
			this.commitCursor();
		}

		selectAll() {
			this.cursors = [new Cursor(0, this.text.length)];
			this.commitCursor();
		}

		selectNextOccurrence(right, move = false) {
			let cursor = this.lastCursor;
			if (cursor.empty)
				return this.replaceLastCursor(...this.wordGrowCursorBoundaries(cursor, false));
			let text = this.getTextAt(cursor);
			let next = this.findNextUnselectedOccurrenceWrapPoint(text, cursor.left, right);
			if (next === -1)
				return;
			if (move)
				this.replaceLastCursor(next, next + text.length);
			else
				this.addCursor(next, next + text.length);
		}

		selectAllOccurrences() {
			let cursor = this.lastCursor.empty ? new Cursor(...this.wordGrowCursorBoundaries(cursor, false)) : this.lastCursor;
			let text = this.getTextAt(cursor);
			let indices = this.findAllOccurrencePoints(text, cursor.left);
			this.addCursors(indices, text.length);
		}

		// cursor methods

		get lastCursor() {
			return this.cursors[this.cursors.length - 1];
		}

		setCursor(start, end = start) {
			this.cursors = [new Cursor(start, end)];
			this.commitCursor();
		}

		addCursor(start, end = start) {
			this.cursors.push(new Cursor(start, end));
			this.mergeCursors();
			this.commitCursor();
		}

		addCursors(starts, length) {
			this.cursors = [...this.cursors, ...starts.map(start => new Cursor(start, start + length))];
			this.mergeCursors();
			this.commitCursor();
		}

		removeLastCursor() {
			if (this.cursors.length === 1)
				return;
			this.cursors.pop();
			this.commitCursor();
		}

		updateLastCursor(end) {
			this.lastCursor.end = end;
			this.mergeCursors();
			this.commitCursor();
		}

		replaceLastCursor(start, end = start) {
			this.cursors.pop();
			this.cursors.push(new Cursor(start, end));
			this.mergeCursors();
			this.commitCursor();
		}

		moveCursors(right, movement, select) {
			this.cursors.forEach(cursor => {
				let newStart = -1;
				let newEnd = cursor.end;
				let d = right * 2 - 1;

				switch (movement) {
					case cursorMovement.CHAR:
						if (cursor.empty || select)
							newEnd = clamp(newEnd + d, 0, this.text.length);
						else
							newEnd = right ? cursor.right : cursor.left;
						break;
					case cursorMovement.ROW: {
						let {x, y} = this.pointToXY(newEnd);
						newEnd = this.xyToPoint(x, y + d);
						break;
					}
					case cursorMovement.LARGE_ROW: {
						let {x, y} = this.pointToXY(newEnd);
						newEnd = this.xyToPoint(x, y + d * 50);
						break;
					}
					case cursorMovement.SUB_WORD:
						newEnd = this.findNextSubWordPoint(newEnd, right);
						break;
					case cursorMovement.WORD:
						newEnd = this.findNextWordPoint(newEnd, right);
						break;
					case cursorMovement.LINE:
						newEnd = this.findNextLinePoint(newEnd, right, false);
						break;
					case cursorMovement.TEXT:
						newEnd = right ? this.text.length : 0;
						break;
					case cursorMovement.GROW:
						if (right)
							newEnd = cursor.start;
						else {
							let tempNewEnd;
							[newStart, tempNewEnd] = this.wordGrowCursorBoundaries(cursor);
							if (tempNewEnd === newEnd && newStart === cursor.left) {
								newStart = this.findNextLinePoint(cursor.left, false);
								newEnd = this.findNextLinePoint(cursor.right, true);
							} else if (tempNewEnd > newEnd)
								newEnd = tempNewEnd;
						}
						break;
					case cursorMovement.GROW_FULL:
						newStart = this.findNextLinePoint(cursor.left, false);
						newEnd = this.findNextLinePoint(cursor.right, true);
						break;
				}

				if (newStart !== -1)
					cursor.set(newStart, newEnd);
				else if (select)
					cursor.end = newEnd;
				else
					cursor.set(newEnd);
			});
			this.mergeCursors();
			this.commitCursor();
		}

		mergeCursors() {
			this.cursors = this.cursors.filter((cursor, i) =>
				!this.cursors.some((cursorNewer, j) =>
					j > i && cursorNewer.mergeWith(cursor)));
		}

		reorderCursors() {
			this.cursors.sort((c1, c2) => c1.left - c2.left);
		}

		// cursor find point methods

		findNextSubWordPoint(point, right) {
			return this.findNextPoint(point, right, /(([A-Z]?[a-z0-9]+_?|[A-Z0-9]+_?|(.)\3*)[^\S\n]*|\n)/);
		}

		findNextWordPoint(point, right, excludeNewLine = false, trailingWhitespace = true) {
			let regex = new RegExp(`((\\w+|(.)\\3*)${trailingWhitespace ? '[^\\S\\n]*' : ''}|\\n)`);
			return this.findNextPoint(point, right, regex, excludeNewLine);
		}

		findNextLinePoint(point, right) {
			return this.findNextPoint(point, right, /.*/);
		}

		findNextLineTextPoint(point, right) {
			return this.findNextPoint(point, right, /.*\s*/);
		}

		findNextPoint(point, right, breakRegex, excludeNewLine = false) {
			let subText = right ? this.text.substring(point) : this.text.substring(0, point);
			let regex = new RegExp(breakRegex.source + (right ? '' : '$'));
			let match = (subText.match(regex) || [''])[0];
			if (excludeNewLine && match === '\n')
				return point;
			return point + (match.length + (point > this.text.length ? 1 : 0)) * (right ? 1 : -1);
		}

		findNextUnselectedOccurrenceWrapPoint(text, point, right) {
			let next = point;
			while (true) {
				next = right ? this.text.indexOf(text, next + 1) : this.text.lastIndexOf(text, next - 1);
				if (next === -1) {
					if (!right)
						next = this.text.length;
					continue;
				}
				if (next === point)
					return -1;
				else if (!this.isSelected(next, next + text.length))
					return next;
			}
		}

		findAllOccurrencePoints(text, point = -1) {
			let indices = [];
			let next = point;
			while (true) {
				next = this.text.indexOf(text, next + 1);
				if (next === -1)
					continue;
				if (next === point)
					return indices;
				indices.push(next);
			}
		}

		wordGrowCursorBoundaries(cursor, trailingWhitespace = true) {
			let start = this.findNextWordPoint(cursor.start + 1, false, trailingWhitespace);
			let end = this.findNextWordPoint(start, true, true, trailingWhitespace);
			return [start, end];
		}

		// clipboard methods

		copy() {
			if (this.cursors.every(cursor => cursor.empty))
				this.moveCursors(false, cursorMovement.GROW_FULL, true);
			let texts = this.cursors.map(cursor => this.getTextAt(cursor));
			this.lastClipboard = texts;
			navigator.clipboard.writeText(texts.join('\n'));
		}

		cut() {
			this.copy();
			this.deleteSelections(false, false, false, false);
		}

		async paste() {
			let text = cleanText(await navigator.clipboard.readText());
			let texts = text.split('\n');
			if (this.cursors.length === 1 || texts.length === 1)
				this.replaceSelections(text);
			else {
				if (this.lastClipboard && this.lastClipboard.length !== 1 && text === this.lastClipboard.join('\n'))
					texts = this.lastClipboard;
				this.replaceSelectionsMulti(texts);
			}
		}

		// history methods

		clonedCursors(cursors = this.cursors) {
			return cursors.map(cursor => cursor.clone);
		}

		commitText() {
			if (!this.history[this.historyIndex].text)
				this.historyIndex++;
			this.history = this.history.slice(0, this.historyIndex);
			this.history[this.historyIndex] = {
				text: this.text,
				cursors: this.clonedCursors(),
			};
		}

		commitCursor() {
			this.history = this.history.slice(0, this.historyIndex + 1);
			this.history[++this.historyIndex] = {cursors: this.clonedCursors()};
		}

		restoreHistory(index) {
			this.text = this.history.slice(0, index + 1).reverse().find(({text}) => text !== undefined).text;
			this.cursors = this.clonedCursors(this.history[index].cursors);
		}

		nextHistory(redo) {
			return {index: this.historyIndex + redo * 2 - 1, textChanged: !this.history[this.historyIndex + redo] || this.history[this.historyIndex + redo].text};
		}

		undo(cursor, redo) {
			let next = this.nextHistory(redo);
			if (!this.history[next.index])
				return;
			if (!cursor) {
				if (next.textChanged)
					this.historyIndex = next.index;
				else
					do {
						this.historyIndex = next.index;
						next = this.nextHistory(redo)
					} while (!next.textChanged);
			} else if (!next.textChanged)
				this.historyIndex = next.index;
			else
				return;
			this.restoreHistory(this.historyIndex);
		}

		// render methods

		render() {
			while ($('#text').firstChild)
				$('#text').removeChild($('#text').firstChild);
			let cursorSplits = this.cursors.flatMap(cursor => [cursor.left, cursor.right, cursor.end + 1]);
			let markedSplits = this.cursors
				.map(cursor => this.getTextAt(cursor).trim() || this.getTextAt(new Cursor(...this.wordGrowCursorBoundaries(cursor, false))).trim())
				.filter(text => text)
				.flatMap(text => {
					let splits = [], i;
					while ((i = this.text.indexOf(text, i + 1)) >= 0)
						splits.push(i);
					return splits.map(split => [split, text.length]);
				});
			let splits = [...cursorSplits, ...markedSplits.flatMap(([split, length]) => [split, split + length])]
				.filter((split, i, a) => a.indexOf(split) === i)
				.sort((s1, s2) => s1 - s2);
			if (splits[0] !== 0)
				splits.unshift(0);
			let paddedText = this.text + ' ';
			let scrollToSpan;
			splits.forEach((split, i, a) => {
				let span = document.createElement('span');
				span.textContent = paddedText.substring(split, a[i + 1]).replace(/\n/g, ' \n');
				span['data-split'] = split;
				if (this.isSelected(split))
					span.classList.add('selected');
				else if (this.cursors.some(cursor => cursor.end === split))
					span.classList.add('ends-at');
				else if (markedSplits.some(([markedSplit, length]) => split >= markedSplit && split < markedSplit + length))
					span.classList.add('marked');
				$('#text').appendChild(span);
				if (split === this.lastCursor.end)
					scrollToSpan = span;
			});
			$('#numbers').textContent = '1\n' + (this.text.match(/\n/g) || []).map((_, i) => i + 2).join('\n');
			scrollToSpan.scrollIntoView({block: 'nearest'});
		}
	}

	let text = Text.restore();
	text.render();

	document.addEventListener('keydown', async e => {
		const homeEndArrowCursorMovement =
			[cursorMovement.LINE, cursorMovement.TEXT, cursorMovement.LINE, cursorMovement.TEXT];
		const horizArrowCursorMovement =
			[cursorMovement.CHAR, cursorMovement.WORD, cursorMovement.LINE, cursorMovement.TEXT];
		const vertArrowCursorMovement =
			[cursorMovement.ROW, cursorMovement.GROW, cursorMovement.LARGE_ROW, cursorMovement.GROW];

		let modifierIndex = e.ctrlKey + e.altKey * 2;
		let noop = false;

		switch (e.key.toLowerCase()) {
			case 'enter':
				text.replaceSelections('\n');
				break;
			case 'tab':
				text.replaceSelections('\t');
				e.preventDefault();
				break;
			case 'home':
				text.moveCursors(false, homeEndArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case 'end':
				text.moveCursors(true, homeEndArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case 'arrowleft':
				text.moveCursors(false, horizArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case 'arrowright':
				text.moveCursors(true, horizArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case 'arrowup':
				e.preventDefault();
				text.moveCursors(false, vertArrowCursorMovement[modifierIndex], e.shiftKey);
				break;
			case 'arrowdown':
				text.moveCursors(true, vertArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case ';':
			case ':':
				if (e.ctrlKey)
					text.moveCursors(false, cursorMovement.SUB_WORD, e.shiftKey);
				break;
			case "'":
			case '"':
				if (e.ctrlKey)
					text.moveCursors(true, cursorMovement.SUB_WORD, e.shiftKey);
				break;
			case 'delete':
				text.deleteSelections(true, e.ctrlKey, e.shiftKey, e.altKey);
				break;
			case 'backspace':
				text.deleteSelections(false, e.ctrlKey, e.shiftKey, e.altKey);
				break;
			case '/':
			case '?':
				if (e.ctrlKey)
					text.toggleCommentSelections(e.shiftKey);
				break;
			case 'f':
				// todo
				break;
			case 'g':
				if (e.ctrlKey || e.altKey) {
					if (e.shiftKey)
						text.removeLastCursor();
					else if (e.ctrlKey && e.altKey)
						text.selectAllOccurrences();
					else
						text.selectNextOccurrence(!e.altKey);
					e.preventDefault();
				}
				break;
			case 'h':
				if (e.ctrlKey) {
					text.selectNextOccurrence(!e.shiftKey, true);
					e.preventDefault()
				}
				break;
			case 'escape':
				text.selectNone();
				break;
			case 'a':
				if (e.ctrlKey) {
					text.selectAll();
					e.preventDefault();
				}
				break;
			case 'c':
				if (e.ctrlKey || e.altKey) {
					// todo, reorder by default, alt key to not reorder, and preserve original cursor ordering
					if (e.altKey)
						text.reorderCursors();
					text.copy();
				}
				break;
			case 'x':
				if (e.ctrlKey || e.altKey) {
					if (e.altKey)
						text.reorderCursors();
					text.cut();
				}
				break;
			case 'v':
				if (e.ctrlKey || e.altKey) {
					if (e.altKey)
						text.reorderCursors();
					await text.paste();
				}
				break;
			case 'z':
				if (e.ctrlKey || e.altKey)
					text.undo(e.altKey, e.shiftKey);
			case ' ':
				e.preventDefault();
			default:
				noop = true;
				if (e.key.length !== 1)
					console.log(e.key, e.ctrlKey, e.shiftKey, e.altKey);
		}
		if (e.key.length === 1 && !e.ctrlKey && !e.altKey)
			text.replaceSelections(e.key);
		else if (noop)
			return;

		text.render();
		text.save();
	});

	let lastMouseDown;
	$('#text').addEventListener('mousedown', e => {
		let now = Date.now();
		if (now - lastMouseDown < 300)
			text.moveCursors(false, cursorMovement.GROW, false); // todo only grow last cursor
		else {
			let point = text.mouseXyToPoint(e.x, e.y);
			if (e.ctrlKey)
				text.addCursor(point);
			else if (e.shiftKey)
				text.updateLastCursor(point);
			else
				text.setCursor(point);
		}
		lastMouseDown = now;
		text.render();
		// todo alt to block cursor
		// todo ctrl to add (or remove) cursor
		// todo on ctrl+alt, add (or remove) block cursor
	});

	let lastMousePoint;
	$('#text').addEventListener('mousemove', e => {
		if (!e.buttons)
			return;
		let point = text.mouseXyToPoint(e.x, e.y);
		if (point === lastMousePoint)
			return;
		lastMousePoint = point;
		text.updateLastCursor(point);
		text.render();
	});

	// TODO

	// highlight selected line

	// remove cursors on click

	// c-f find
	// c-r replace

	// c-g select next
	// c-s-g remove last-next selection
	// c-a-g select all
	// a-g select prev
	// a-s-g remove last-prev selection
	// c-h goto next
	// c-s-h goto previous

	// search by regex and whole word and case sensitive

	// tab to indent / unindent, ctrl tab to clone indentation form above line
	// m matching paren
	// on paren, add closing paren. wrap selected text

	// move lines up down
	// delete, duplicate, uppercase toggle
	// c-s-up/down -> move line up/down

	// prev/next edit location

	// autocomplete

	// alt shift arrows to create cursors

	// zoom in / out / default

	// display line, column, selection numbers.
	// goto line number

	// tabs and files

	// home/end to toggle between to post-whitespace and pre-whitespace,
	// arrows to not move cursor when have selection

	// a-,/. -> prev / next edit location,
	// c-,/. -> prev / next cursor location

	// snapshots and diff comparisons

	// DONE

	// typing
	// multi selection
	// merging overlapping cursors
	// mouse drag select
	// mouse single, double, triple click
	// highlight occurrences of selected text

	// del/backspace -> char
	// c-del/backspace -> word
	// s-del/backspace -> line end
	// a-del/backspace -> entire line

	// c-a
	// escape

	// c-/

	// c-x/c/v -> copy, cut, paste.
	// a-x/c/v -> copy, cut, paste with reordered cursors
	// copy/cut entire lines if nothing selected.
	// copy/cut/paste support multiline

	// left/right -> char
	// c-left/right -> word left/right
	// a-left/right -> line start/end
	// c-a-left/right -> text start/end
	// home/end -> line start/end
	// c-up/down -> grow/shrink
	// up/down -> row
	// c-home/end -> text start/end
	// c-;/' -> sub word

	// c-z -> udno
	// c-s-z -> redo
	// a-z or c-a-z -> undo cursor
	// a-s-z or c-a-s-z -> redo cursor
</script>
