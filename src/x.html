<style>
	#text {
		outline: 1px solid;
		overflow: auto;
		font-size: 16px;
		user-select: none;
	}

	span.selected {
		color: #fff;
		background: #333;
	}

	span.ends-at {
		color: #000;
		background: #ddd;
	}
</style>

<pre id="text"></pre>

<script>
	const $ = document.querySelector.bind(document);

	const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

	class Cursor {
		constructor(left = 0, right = left, reverse = false) {
			this.set(left, right, reverse);
		}

		static createUnordered(start, end) {
			// todo consider replacing constructor with this method
			return start > end ? new Cursor(end, start, true) : new Cursor(start, end);
		}

		set(left = 0, right = left, reverse = false) {
			this.left = left;
			this.right = right;
			this.reverse = reverse;
		}

		get clone() {
			return new Cursor(this.left, this.right, this.reverse);
		}

		// shifts this according to removal of cursor
		shiftByRemovalOf(cursor) {
			this.left = cursor.shiftPointForRemoval(this.left);
			this.right = cursor.shiftPointForRemoval(this.right);
		}

		// shifts point according to removal of this
		shiftPointForRemoval(point) {
			return point - Math.max(Math.min(point, this.right) - this.left, 0);
		}

		// shifts this according to insertion
		shiftByInsertionOf(insertionPoint, insertionLength) {
			if (insertionPoint <= this.left)
				this.left += insertionLength;
			if (insertionPoint <= this.right)
				this.right += insertionLength;
		}

		get empty() {
			return this.left === this.right;
		}

		get start() {
			return this.reverse ? this.right : this.left;
		}

		get end() {
			return this.reverse ? this.left : this.right;
		}

		set end(end) {
			let start = this.start;
			this.reverse = end < start;
			this.left = this.reverse ? end : start;
			this.right = this.reverse ? start : end;
		}

		endsAt(point) {
			return point === this.end;
		}

		includes(point) {
			return point >= this.left && point < this.right;
		}
	}

	class Text {
		constructor(text = '', cursors = [new Cursor()]) {
			this.text = text;
			this.cursors = cursors;
		}

		static restore() {
			return new Text(
				localStorage.getItem('text') || '');
		}

		save() {
			localStorage.setItem('text', this.text);
		}

		pointToXY(point) {
			let preText = this.text.substring(0, point);
			let y = (preText.match(/\n/g) || []).length;
			let x = preText.match(/.*$/)[0].length;
			return {x, y};
		}

		xyToPoint(x, y) {
			return y >= 0 ? this.text.match(new RegExp(`(.*\\n?){0,${y}}.{0,${x}}`))[0].length : 0;
		}

		mouseXyToPoint(x, y) {
			let {startContainer: textNode, startOffset: offset} = document.caretRangeFromPoint(x, y);
			let point = textNode.parentNode['data-split'] + offset - (textNode.textContent.slice(0, offset + 1).match(/ \n/g) || []).length;
			return clamp(point, 0, this.text.length);
		}

		// text editing methods

		getTextAt(cursor) {
			return this.text.substring(cursor.left, cursor.right);
		}

		removeTextAt(cursor) {
			this.text = this.text.substring(0, cursor.left) + this.text.substring(cursor.right);
			this.cursors.forEach(cursorI => cursorI.shiftByRemovalOf(cursor));
		}

		insertTextAt(text, point) {
			this.text = this.text.substring(0, point) + text + this.text.substring(point);
			this.cursors.forEach(cursorI => cursorI.shiftByInsertionOf(point, text.length));
		}

		replaceSelections(text) {
			this.cursors.forEach(cursor => {
				this.removeTextAt(cursor);
				this.insertTextAt(text, cursor.end);
			});
		}

		deleteSelections(right, word, line, allLine) {
			this.cursors.forEach(cursor => {
				let delIndices = [cursor.left, cursor.right];
				let i = right + 0;
				if (allLine) {
					delIndices[0] = this.findNextLinePoint(delIndices[0], false);
					delIndices[1] = this.findNextLinePoint(delIndices[1], true) + 1;
				} else if (delIndices[0] !== delIndices[1])
					;
				else if (line)
					delIndices[i] = this.findNextLinePoint(delIndices[i], right);
				else if (word)
					delIndices[i] = this.findNextWordPoint(delIndices[i], right);
				else
					delIndices[i] = clamp(delIndices[i] + right * 2 - 1, 0, this.text.length);
				this.removeTextAt(new Cursor(delIndices[0], delIndices[1]));
			});
		}

		toggleCommentSelections(inline) {
			this.cursors.forEach(cursor => {
				if (inline) {
					// todo inline commenting
				} else {
					// todo if multiple lines selected, comment/uncomment all
					let prefixPoint = this.findNextLineTextPoint(cursor.left, false);
					let prefixCursor = new Cursor(prefixPoint, prefixPoint + 3);
					if (this.getTextAt(prefixCursor) === '// ')
						this.removeTextAt(prefixCursor);
					else
						this.insertTextAt('// ', prefixPoint);
				}
			});
		}

		// cursor methods

		selectNone() {
			this.cursors = [new Cursor(this.cursors[0].end)];
		}

		selectAll() {
			this.cursors = [new Cursor(0, this.text.length)];
		}

		setCursor(start, end) {
			this.cursors = [Cursor.createUnordered(start, end)];
		}

		addCursor(start, end) {
			this.cursors.push(Cursor.createUnordered(start, end));
		}

		updateLastCursor(end) {
			this.cursors[this.cursors.length - 1].end = end;
		}

		moveCursors(right, vertical, word, line, select) {
			this.cursors.forEach(cursor => {
				let newStart = -1;
				let newEnd = cursor.end;

				if (line)
					newEnd = this.findNextLinePoint(newEnd, right);

				else if (word) {
					if (vertical && !right) {
						newStart = this.findNextWordPoint(cursor.start + 1, false);
						let tempNewEnd = this.findNextWordPoint(cursor.start, true);
						if (tempNewEnd === newEnd && newStart === cursor.left) {
							newStart = this.findNextLinePoint(cursor.left, false);
							newEnd = this.findNextLinePoint(cursor.right, true);
						} else if (tempNewEnd > newEnd)
							newEnd = tempNewEnd;
					} else if (vertical && right)
						newEnd = cursor.start;
					else
						newEnd = this.findNextWordPoint(newEnd, right);

				} else {
					let d = right * 2 - 1;
					if (vertical) {
						let {x, y} = this.pointToXY(newEnd);
						newEnd = this.xyToPoint(x, y + d);
					} else
						newEnd = clamp(newEnd + d, 0, this.text.length);
				}

				if (newStart !== -1)
					cursor.set(newStart, newEnd);
				else if (select)
					cursor.end = newEnd;
				else
					cursor.set(newEnd);
			})
		}

		findNextWordPoint(point, right) {
			return this.findNextPoint(point, right, /(\w+|(.)\2*)\s*/);
		}

		findNextLinePoint(point, right) {
			return this.findNextPoint(point, right, /.*/);
		}

		findNextLineTextPoint(point, right) {
			return this.findNextPoint(point, right, /.*\s*/);
		}

		findNextPoint(point, right, breakRegex) {
			let subText = right ? this.text.substring(point) : this.text.substring(0, point);
			let regex = new RegExp(breakRegex.source + (right ? '' : '$'));
			let move = (subText.match(regex) || [''])[0].length;
			return point + (move + (point > this.text.length ? 1 : 0)) * (right ? 1 : -1);
		}

		// clipboard methods

		copy() {
			// todo multi cursor copy, cut, paste
			let text = this.getTextAt(this.cursors[0]);
			navigator.clipboard.writeText(text);
		}

		cut() {
			let text = this.getTextAt(this.cursors[0]);
			this.removeTextAt(this.cursors[0]);
			navigator.clipboard.writeText(text);
		}

		async paste() {
			let text = await navigator.clipboard.readText();
			this.replaceSelections(text);
		}

		// render methods

		render() {
			while ($('#text').firstChild)
				$('#text').removeChild($('#text').firstChild);
			let splits = this.cursors
				.flatMap(cursor => [cursor.left, cursor.right, cursor.end + 1])
				.filter((split, i, a) => a.indexOf(split) === i)
				.sort((s1, s2) => s1 - s2);
			if (splits[0] !== 0)
				splits.unshift(0);
			let paddedText = this.text + ' ';
			splits.forEach((split, i, a) => {
				let span = document.createElement('span');
				span.textContent = paddedText.substring(split, a[i + 1]).replace(/\n/g, ' \n');
				span['data-split'] = split;
				if (this.cursors.some(cursor => cursor.includes(split)))
					span.classList.add('selected');
				else if (this.cursors.some(cursor => cursor.endsAt(split)))
					span.classList.add('ends-at');
				$('#text').appendChild(span);
			});
		}
	}

	let text = Text.restore();
	text.render();
	// let text = new Text('hello world\nline 2\nand line 3, the last line', [new Cursor(2, 4), new Cursor(7, 10, true)]);
	//                       ^^_  _^^ [0, 2, 4, 5, 7, 8, 10]

	document.addEventListener('keydown', async e => {
		let preventType;

		switch (e.key) {
			case 'Enter':
				text.replaceSelections('\n');
				break;
			case 'Home':
				text.moveCursors(false, false, false, true, e.shiftKey);
				break;
			case 'End':
				text.moveCursors(true, false, false, true, e.shiftKey);
				break;
			case 'ArrowLeft':
				text.moveCursors(false, false, e.ctrlKey, e.altKey, e.shiftKey);
				break;
			case 'ArrowRight':
				text.moveCursors(true, false, e.ctrlKey, e.altKey, e.shiftKey);
				break;
			case 'ArrowUp':
				// todo ctrl up selects more than 1 line after 2rd time
				text.moveCursors(false, true, e.ctrlKey, e.altKey, e.shiftKey);
				break;
			case 'ArrowDown':
				text.moveCursors(true, true, e.ctrlKey, e.altKey, e.shiftKey);
				break;
			case 'Delete':
				text.deleteSelections(true, e.ctrlKey, e.shiftKey, e.altKey);
				break;
			case 'Backspace':
				text.deleteSelections(false, e.ctrlKey, e.shiftKey, e.altKey);
				break;
			case '/':
				if (preventType = e.ctrlKey)
					text.toggleCommentSelections(e.shiftKey);
				break;
			case 'Escape':
				text.selectNone();
				break;
			case 'a':
				if (preventType = e.ctrlKey) {
					text.selectAll();
					e.preventDefault();
				}
				break;
			case 'c':
				if (preventType = e.ctrlKey)
					text.copy();
				break;
			case 'x':
				if (preventType = e.ctrlKey)
					text.cut();
				break;
			case 'v':
				if (preventType = e.ctrlKey)
					await text.paste();
				break;
			default:
				if (e.key.length !== 1)
					console.log(e.key, e.ctrlKey, e.shiftKey, e.altKey);
		}
		if (e.key.length === 1 && !preventType)
			text.replaceSelections(e.key);

		text.render();
		text.save();
	});

	let lastMouseDown;
	document.addEventListener('mousedown', e => {
		if (Date.now() - lastMouseDown < 300)
			text.moveCursors(false, true, true, false, false);
		else {
			let point = text.mouseXyToPoint(e.x, e.y);
			text.setCursor(point);
		}
		lastMouseDown = Date.now();
		text.render();
		// todo on shift, extend selection
		// todo on alt, add or remove cursor
	});

	document.addEventListener('mousemove', e => {
		if (!e.buttons)
			return;
		let point = text.mouseXyToPoint(e.x, e.y);
		text.updateLastCursor(point);
		text.render();
	});

	// c-g select next
	// c-s-g remove last selection
	// c-a-g select all
	// c-h goto next
	// c-s-h goto previous

	// goto text

	// search by regex and whole word and case sensitive

	// tab to indent / unindent, ctrl tab to clone indentation form above line
	// m matching paren

	// on paren, add closing paren. wrap selected text

	// move lines up down
	// delete, duplicate, uppercase toggle

	// undo redo
	// prev/next edit location
	// prev/next cursor location

	// autocomplete

	// copy paste cut

	// move cursor sub word

	// arrows to not move cursor when have selection

	// alt shift arrows to create cursors

	// zoom in / out / default

	// display line, column, selection numbers

	// tabs and files

	// ctrl alt left/right arrow & ctrl home/end to move to start or end of text. work with shift pressed too
</script>
