<style>
	#text {
		outline: 1px solid;
		overflow: auto;
		font-size: 16px;
	}

	span.selected {
		color: #fff;
		background: #333;
	}

	span.ends-at {
		color: #000;
		background: #ddd;
	}
</style>

<pre id="text"></pre>

<script>
	const $ = document.querySelector.bind(document);

	const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

	class Cursor {
		constructor(left = 0, right = left, reverse = false) {
			this.set(left, right, reverse);
		}

		set(left = 0, right = left, reverse = false) {
			this.left = left;
			this.right = right;
			this.reverse = reverse;
		}

		get clone() {
			return new Cursor(this.left, this.right, this.reverse);
		}

		// shifts this according to removal of cursor
		shiftByRemovalOf(cursor) {
			this.left = cursor.shiftPointForRemoval(this.left);
			this.right = cursor.shiftPointForRemoval(this.right);
		}

		// shifts point according to removal of this
		shiftPointForRemoval(point) {
			return point - Math.max(Math.min(point, this.right) - this.left, 0);
		}

		// shifts this according to insertion
		shiftByInsertionOf(insertionPoint, insertionLength) {
			if (insertionPoint <= this.left)
				this.left += insertionLength;
			if (insertionPoint <= this.right)
				this.right += insertionLength;
		}

		get start() {
			return this.reverse ? this.right : this.left;
		}

		get end() {
			return this.reverse ? this.left : this.right;
		}

		set end(end) {
			let start = this.start;
			this.reverse = end < start;
			this.left = this.reverse ? end : start;
			this.right = this.reverse ? start : end;
		}

		endsAt(point) {
			return point === this.end;
		}

		includes(point) {
			return point >= this.left && point < this.right;
		}
	}

	class Text {
		constructor(text = '', cursors = [new Cursor()]) {
			this.text = text;
			this.cursors = cursors;
		}

		pointToXY(point) {
			let preText = this.text.slice(0, point);
			let y = (preText.match(/\n/g) || []).length;
			let x = preText.match(/.*$/)[0].length;
			return {x, y};
		}

		xyToPoint(x, y) {
			return y >= 0 ? this.text.match(new RegExp(`(.*\\n?){0,${y}}.{0,${x}}`))[0].length : 0;
		}

		// text editing methods

		removeTextAt(cursor) {
			this.text = this.text.slice(0, cursor.left) + this.text.slice(cursor.right);
			this.cursors.forEach(cursorI => cursorI.shiftByRemovalOf(cursor));
		}

		insertTextAt(text, point) {
			this.text = this.text.slice(0, point) + text + this.text.slice(point);
			this.cursors.forEach(cursorI => cursorI.shiftByInsertionOf(point, text.length));
		}

		replaceSelections(text) {
			this.cursors.forEach(cursor => {
				this.removeTextAt(cursor);
				this.insertTextAt(text, cursor.end);
			});
		}

		// cursor methods

		moveCursors(dx, dy, word, collapse) {
			this.cursors.forEach(cursor => {
				let newStart = -1;
				let newEnd = cursor.end;

				if (word) {
					if (dy < 0) {
						newStart = this.findNextWordPoint(cursor.start + 1, false);
						let tempNewEnd = this.findNextWordPoint(cursor.start, true);
						if (tempNewEnd === newEnd && newStart === cursor.left) {
							newStart = this.findNextLinePoint(cursor.left, false);
							newEnd = this.findNextLinePoint(cursor.right, true);
						} else if (tempNewEnd > newEnd)
							newEnd = tempNewEnd;
					} else if (dy > 0)
						newEnd = cursor.start;
					if (dx)
						newEnd = this.findNextWordPoint(newEnd, dx > 0);

				} else {
					if (dy) {
						let {x, y} = this.pointToXY(newEnd);
						newEnd = this.xyToPoint(x, y + dy);
					}
					newEnd = clamp(newEnd + dx, 0, this.text.length);
				}

				if (newStart !== -1)
					cursor.set(newStart, newEnd);
				else if (collapse)
					cursor.set(newEnd);
				else
					cursor.end = newEnd;
			});
		}

		findNextWordPoint(point, right) {
			return this.findNextPoint(point, right, /(\w+|(.)\2*)\s*/);
		}

		findNextLinePoint(point, right) {
			return this.findNextPoint(point, right, /(.*)/);
		}

		findNextPoint(point, right, breakRegex) {
			let subText = right ? this.text.slice(point) : this.text.slice(0, point);
			let regex = new RegExp(breakRegex.source + (right ? '' : '$'));
			let move = (subText.match(regex) || [''])[0].length;
			return point + (move + (point > this.text.length ? 1 : 0)) * (right ? 1 : -1);
		}

		render() {
			while ($('#text').firstChild)
				$('#text').removeChild($('#text').firstChild);
			let splits = this.cursors
				.flatMap(cursor => [cursor.left, cursor.right, cursor.end + 1])
				.filter((split, i, a) => a.indexOf(split) === i)
				.sort((s1, s2) => s1 - s2);
			if (splits[0] !== 0)
				splits.unshift(0);
			let paddedText = this.text + ' ';
			splits.forEach((split, i, a) => {
				let span = document.createElement('span');
				span.textContent = paddedText.slice(split, a[i + 1]).replace(/\n/g, ' \n');
				if (this.cursors.some(cursor => cursor.includes(split)))
					span.classList.add('selected');
				else if (this.cursors.some(cursor => cursor.endsAt(split)))
					span.classList.add('ends-at');
				$('#text').appendChild(span);
			});
		}
	}

	let text = new Text('this is some words');
	text.render();
	// let text = new Text('hello world\nline 2\nand line 3, the last line', [new Cursor(2, 4), new Cursor(7, 10, true)]);
	//                       ^^_  _^^ [0, 2, 4, 5, 7, 8, 10]

	document.addEventListener('keydown', e => {
		switch (e.key) {
			case 'Escape':
				text.cursors = [text.cursors[0]];
				break;
			case 'Enter':
				text.replaceSelections('\n');
				break;
			case 'ArrowLeft':
				text.moveCursors(-1, 0, e.ctrlKey, !e.shiftKey);
				break;
			case 'ArrowRight':
				text.moveCursors(1, 0, e.ctrlKey, !e.shiftKey);
				break;
			case 'ArrowUp':
				text.moveCursors(0, -1, e.ctrlKey, !e.shiftKey);
				break;
			case 'ArrowDown':
				text.moveCursors(0, 1, e.ctrlKey, !e.shiftKey);
				break;
			default:
				if (e.key.length === 1)
					text.replaceSelections(e.key);
				else
					console.log(e.key, e.ctrlKey, e.shiftKey, e.altKey);
		}
		text.render();
	});

	// zoom in / out / default

	// move with ctrl, (alt) home/end,

	// del, backspace

	// c-g select next
	// c-s-g remove last selection
	// c-a-g select all
	// c-h goto next
	// c-s-h goto previous

	// goto text

	// tab to indent / unindent
	// m matching paren

	// on paren, add closing paren. wrap selected text

	// move lines up down
	// delete,  duplicate, comment lines

	// mouse cursor

	// undo redo
	// prev/next edit location
	// prev/next cursor location

	// autocomplete

	// ctrl a select al

	// copy paste cut

	// move cursor sub word

</script>
