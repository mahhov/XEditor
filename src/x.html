<style>
	body {
		display: flex;
	}

	#text {
		flex: 1;
		margin: 0;
		outline: 1px solid;
		overflow: auto;
		font-size: 16px;
		user-select: none;
	}

	span.selected {
		color: #fff;
		background: #333;
	}

	span.ends-at {
		color: #000;
		background: #ddd;
	}
</style>

<pre id="text"></pre>

<script>
	const $ = document.querySelector.bind(document);

	const cleanText = text => text.replace(/\r\n?/g, '\n');
	const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

	const cursorMovement = {
		CHAR: 0,
		ROW: 1,
		SUB_WORD: 2,
		WORD: 3,
		LINE: 4,
		TEXT: 5,
		GROW: 6,
		GROW_FULL: 7,
	};

	class Cursor {
		constructor(start = 0, end = start) {
			if (start <= end)
				this.set(start, end);
			else
				this.set(end, start, true);
		}

		set(left = 0, right = left, reverse = false) {
			this.left = left;
			this.right = right;
			this.reverse = reverse;
		}

		get clone() {
			return new Cursor(this.start, this.right);
		}

		// shifts this according to removal of cursor
		shiftByRemovalOf(cursor) {
			this.left = cursor.shiftPointForRemoval(this.left);
			this.right = cursor.shiftPointForRemoval(this.right);
		}

		// shifts point according to removal of this
		shiftPointForRemoval(point) {
			return point - Math.max(Math.min(point, this.right) - this.left, 0);
		}

		// shifts this according to insertion
		shiftByInsertionOf(insertionPoint, insertionLength) {
			if (insertionPoint <= this.left)
				this.left += insertionLength;
			if (insertionPoint <= this.right)
				this.right += insertionLength;
		}

		get empty() {
			return this.left === this.right;
		}

		get start() {
			return this.reverse ? this.right : this.left;
		}

		get end() {
			return this.reverse ? this.left : this.right;
		}

		set end(end) {
			let start = this.start;
			this.reverse = end < start;
			this.left = this.reverse ? end : start;
			this.right = this.reverse ? start : end;
		}

		includes(point) {
			return point >= this.left && point < this.right;
		}

		// if this and cursor overlap, merge and return true
		mergeWith(cursor) {
			if (this.left > cursor.right || cursor.left > this.right)
				return false;
			this.set(Math.min(this.left, cursor.left), Math.max(this.right, cursor.right));
			return true;
		}
	}

	class Text {
		constructor(text = '', cursors = [new Cursor()]) {
			this.text = text;
			this.cursors = cursors;
		}

		static restore() {
			return new Text(
				localStorage.getItem('text') || '');
		}

		save() {
			localStorage.setItem('text', this.text);
		}

		pointToXY(point) {
			let preText = this.text.substring(0, point);
			let y = (preText.match(/\n/g) || []).length;
			let x = preText.match(/.*$/)[0].length;
			return {x, y};
		}

		xyToPoint(x, y) {
			return y >= 0 ? this.text.match(new RegExp(`(.*\\n?){0,${y}}.{0,${x}}`))[0].length : 0;
		}

		mouseXyToPoint(x, y) {
			let {startContainer: textNode, startOffset: offset} = document.caretRangeFromPoint(x, y);
			let point = textNode.parentNode['data-split'] + offset - (textNode.textContent.slice(0, offset + 1).match(/ \n/g) || []).length;
			return clamp(point, 0, this.text.length);
		}

		// base text editing methods

		getTextAt(cursor) {
			return this.text.substring(cursor.left, cursor.right);
		}

		removeTextAt(cursor) {
			this.text = this.text.substring(0, cursor.left) + this.text.substring(cursor.right);
			this.cursors.forEach(cursorI => cursorI.shiftByRemovalOf(cursor));
		}

		insertTextAt(text, point) {
			text = cleanText(text);
			this.text = this.text.substring(0, point) + text + this.text.substring(point);
			this.cursors.forEach(cursorI => cursorI.shiftByInsertionOf(point, text.length));
		}

		// text editing methods

		replaceSelections(text) {
			this.replaceSelectionsMulti(this.cursors.map(() => text));
		}

		replaceSelectionsMulti(texts) {
			this.cursors.forEach((cursor, i) => {
				this.removeTextAt(cursor);
				this.insertTextAt(texts[i] || '', cursor.end);
			});
			this.mergeCursors();
		}

		deleteSelections(right, word, line, allLine) {
			// todo migrate parameter to cursorMovement enum
			this.cursors.forEach(cursor => {
				let delIndices = [cursor.left, cursor.right];
				let i = right + 0;
				if (allLine) {
					delIndices[0] = this.findNextLinePoint(delIndices[0], false);
					delIndices[1] = this.findNextLinePoint(delIndices[1], true) + 1;
				} else if (delIndices[0] !== delIndices[1])
					;
				else if (line)
					delIndices[i] = this.findNextLinePoint(delIndices[i], right);
				else if (word)
					delIndices[i] = this.findNextWordPoint(delIndices[i], right, false);
				else
					delIndices[i] = clamp(delIndices[i] + right * 2 - 1, 0, this.text.length);
				this.removeTextAt(new Cursor(delIndices[0], delIndices[1]));
			});
			this.mergeCursors();
		}

		toggleCommentSelections(inline) {
			this.cursors.forEach(cursor => {
				if (inline) {
					// todo inline commenting
				} else {
					// todo if multiple lines selected, comment/uncomment all
					let prefixPoint = this.findNextLineTextPoint(cursor.left, false);
					let prefixCursor = new Cursor(prefixPoint, prefixPoint + 3);
					if (this.getTextAt(prefixCursor) === '// ')
						this.removeTextAt(prefixCursor);
					else
						this.insertTextAt('// ', prefixPoint);
				}
			});
			this.mergeCursors();
		}

		// cursor methods

		selectNone() {
			this.cursors = [new Cursor(this.cursors[0].end)];
		}

		selectAll() {
			this.cursors = [new Cursor(0, this.text.length)];
		}

		setCursor(start, end = start) {
			this.cursors = [new Cursor(start, end)];
		}

		addCursor(start, end = start) {
			this.cursors.push(new Cursor(start, end));
			this.mergeCursors();
		}

		updateLastCursor(end) {
			this.cursors[this.cursors.length - 1].end = end;
			this.mergeCursors();
		}

		moveCursors(right, movement, select) {
			this.cursors.forEach(cursor => {
				let newStart = -1;
				let newEnd = cursor.end;
				let d = right * 2 - 1;

				switch (movement) {
					case cursorMovement.CHAR:
						newEnd = clamp(newEnd + d, 0, this.text.length);
						break;
					case cursorMovement.ROW:
						let {x, y} = this.pointToXY(newEnd);
						newEnd = this.xyToPoint(x, y + d);
						break;
					case cursorMovement.SUB_WORD:
						newEnd = this.findNextSubWordPoint(newEnd, right);
						break;
					case cursorMovement.WORD:
						newEnd = this.findNextWordPoint(newEnd, right, false);
						break;
					case cursorMovement.LINE:
						newEnd = this.findNextLinePoint(newEnd, right, false);
						break;
					case cursorMovement.TEXT:
						newEnd = right ? this.text.length : 0;
						break;
					case cursorMovement.GROW:
						if (right)
							newEnd = cursor.start;
						else {
							newStart = this.findNextWordPoint(cursor.start + 1, false);
							let tempNewEnd = this.findNextWordPoint(newStart, true, true);
							if (tempNewEnd === newEnd && newStart === cursor.left) {
								newStart = this.findNextLinePoint(cursor.left, false);
								newEnd = this.findNextLinePoint(cursor.right, true);
							} else if (tempNewEnd > newEnd)
								newEnd = tempNewEnd;
						}
						break;
					case cursorMovement.GROW_FULL:
						newStart = this.findNextLinePoint(cursor.left, false);
						newEnd = this.findNextLinePoint(cursor.right, true);
						break;
				}

				if (newStart !== -1)
					cursor.set(newStart, newEnd);
				else if (select)
					cursor.end = newEnd;
				else
					cursor.set(newEnd);
			});
			this.mergeCursors();
		}

		mergeCursors() {
			this.cursors = this.cursors.filter((cursor, i) =>
				!this.cursors.some((cursorNewer, j) =>
					j > i && cursorNewer.mergeWith(cursor)));
		}

		// cursor find point methods

		findNextSubWordPoint(point, right) {
			return this.findNextPoint(point, right, /(([a-z]+|[A-Z]+|[0-9]+|(.)\3*)[^\S\n]*|\n)/);
		}

		findNextWordPoint(point, right, excludeNewLine) {
			return this.findNextPoint(point, right, /((\w+|(.)\3*)[^\S\n]*|\n)/, excludeNewLine);
		}

		findNextLinePoint(point, right) {
			return this.findNextPoint(point, right, /.*/);
		}

		findNextLineTextPoint(point, right) {
			return this.findNextPoint(point, right, /.*\s*/);
		}

		findNextPoint(point, right, breakRegex, excludeNewLine = false) {
			let subText = right ? this.text.substring(point) : this.text.substring(0, point);
			let regex = new RegExp(breakRegex.source + (right ? '' : '$'));
			let match = (subText.match(regex) || [''])[0];
			if (excludeNewLine && match === '\n')
				return point;
			return point + (match.length + (point > this.text.length ? 1 : 0)) * (right ? 1 : -1);
		}

		// clipboard methods

		copy() {
			// todo shift copy/cut/paste to reorder cursors
			if (this.cursors.every(cursor => cursor.empty))
				this.moveCursors(false, cursorMovement.GROW_FULL, true);
			let texts = this.cursors.map(cursor => this.getTextAt(cursor));
			this.lastClipboard = texts;
			navigator.clipboard.writeText(texts.join('\n'));
		}

		cut() {
			this.copy();
			this.deleteSelections(false, false, false, false);
		}

		async paste() {
			let text = cleanText(await navigator.clipboard.readText());
			let texts = text.split('\n');
			if (this.cursors.length === 1 || texts.length === 1)
				this.replaceSelections(text);
			else {
				if (this.lastClipboard && this.lastClipboard.length !== 1 && text === this.lastClipboard.join('\n'))
					texts = this.lastClipboard;
				this.replaceSelectionsMulti(texts);
			}
		}

		// render methods

		render() {
			while ($('#text').firstChild)
				$('#text').removeChild($('#text').firstChild);
			let splits = this.cursors
				.flatMap(cursor => [cursor.left, cursor.right, cursor.end + 1])
				.filter((split, i, a) => a.indexOf(split) === i)
				.sort((s1, s2) => s1 - s2);
			if (splits[0] !== 0)
				splits.unshift(0);
			let paddedText = this.text + ' ';
			splits.forEach((split, i, a) => {
				let span = document.createElement('span');
				span.textContent = paddedText.substring(split, a[i + 1]).replace(/\n/g, ' \n');
				span['data-split'] = split;
				if (this.cursors.some(cursor => cursor.includes(split)))
					span.classList.add('selected');
				else if (this.cursors.some(cursor => cursor.end === split))
					span.classList.add('ends-at');
				$('#text').appendChild(span);
			});
		}
	}

	let text = Text.restore();
	text.render();
	// let text = new Text('hello world\nline 2\nand line 3, the last line', [new Cursor(2, 4), new Cursor(10, 7)]);
	//                       ^^_  _^^ [0, 2, 4, 5, 7, 8, 10]

	document.addEventListener('keydown', async e => {
		const homeEndArrowCursorMovement =
			[cursorMovement.LINE, cursorMovement.TEXT, cursorMovement.LINE, cursorMovement.TEXT];
		const horizArrowCursorMovement =
			[cursorMovement.CHAR, cursorMovement.WORD, cursorMovement.LINE, cursorMovement.TEXT];
		const vertArrowCursorMovement =
			[cursorMovement.ROW, cursorMovement.GROW, cursorMovement.ROW, cursorMovement.GROW];

		let modifierIndex = e.ctrlKey + e.altKey * 2;
		let preventType;

		switch (e.key) {
			case 'Enter':
				text.replaceSelections('\n');
				break;
			case 'Home':
				text.moveCursors(false, homeEndArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case 'End':
				text.moveCursors(true, homeEndArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case 'ArrowLeft':
				text.moveCursors(false, horizArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case 'ArrowRight':
				text.moveCursors(true, horizArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case 'ArrowUp':
				e.preventDefault();
				text.moveCursors(false, vertArrowCursorMovement[modifierIndex], e.shiftKey);
				break;
			case 'ArrowDown':
				text.moveCursors(true, vertArrowCursorMovement[modifierIndex], e.shiftKey);
				e.preventDefault();
				break;
			case ';':
				if (preventType = e.ctrlKey)
					text.moveCursors(false, cursorMovement.SUB_WORD, e.shiftKey);
				break;
			case "'":
				if (preventType = e.ctrlKey)
					text.moveCursors(true, cursorMovement.SUB_WORD, e.shiftKey);
				break;
			case 'Delete':
				text.deleteSelections(true, e.ctrlKey, e.shiftKey, e.altKey);
				break;
			case 'Backspace':
				text.deleteSelections(false, e.ctrlKey, e.shiftKey, e.altKey);
				break;
			case '/':
				if (preventType = e.ctrlKey)
					text.toggleCommentSelections(e.shiftKey);
				break;
			case 'Escape':
				text.selectNone();
				break;
			case 'a':
				if (preventType = e.ctrlKey) {
					text.selectAll();
					e.preventDefault();
				}
				break;
			case 'c':
				if (preventType = e.ctrlKey)
					text.copy();
				break;
			case 'x':
				if (preventType = e.ctrlKey)
					text.cut();
				break;
			case 'v':
				if (preventType = e.ctrlKey)
					await text.paste();
				break;
			case ' ':
				e.preventDefault();
			default:
				if (e.key.length !== 1)
					console.log(e.key, e.ctrlKey, e.shiftKey, e.altKey);
		}
		if (e.key.length === 1 && !preventType)
			text.replaceSelections(e.key);

		text.render();
		text.save();
	});

	let lastMouseDown;
	document.addEventListener('mousedown', e => {
		let now = Date.now();
		if (now - lastMouseDown < 300)
			text.moveCursors(false, cursorMovement.GROW, false); // todo only grow last cursor
		else {
			let point = text.mouseXyToPoint(e.x, e.y);
			if (e.ctrlKey)
				text.addCursor(point);
			else if (e.shiftKey)
				text.updateLastCursor(point);
			else
				text.setCursor(point);
		}
		lastMouseDown = now;
		text.render();
		// todo alt to block cursor
		// todo ctrl to add (or remove) cursor
		// todo on ctrl+alt, add (or remove) block cursor
	});

	document.addEventListener('mousemove', e => {
		if (!e.buttons)
			return;
		let point = text.mouseXyToPoint(e.x, e.y);
		text.updateLastCursor(point);
		text.render();
	});

	// TODO

	// copy, cut to work on line when nothing selected
	// multiline copy cut paste

	// merge overlapping cursors
	// remove cursors on click
	// highlight occurences of selected text

	// c-f find
	// c-r replace

	// c-g select next
	// c-s-g remove last-next selection
	// c-a-g select all
	// a-g select prev
	// a-s-g remove last-prev selection
	// c-h goto next
	// c-s-h goto previous

	// goto text

	// search by regex and whole word and case sensitive

	// tab to indent / unindent, ctrl tab to clone indentation form above line
	// m matching paren
	// on paren, add closing paren. wrap selected text

	// move lines up down
	// delete, duplicate, uppercase toggle
	// c-s-up/down -> move line up/down

	// undo redo
	// prev/next edit location
	// prev/next cursor location

	// autocomplete

	// alt shift arrows to create cursors

	// zoom in / out / default

	// display line, column, selection numbers.
	// goto line number

	// tabs and files

	// home/end to toggle between to post-whitespace and pre-whitespace,
	// arrows to not move cursor when have selection

	// a-,/. -> prev / next edit location,
	// c-,/. -> prev / next cursor location

	// snapshots and diff comparisons

	// DONE

	// typing

	// del/backspace
	// c-del/backspace

	// c-a
	// escape

	// c-/
	// c-c/x/v

	// mouse drag select
	// mouse single, double, triple click

	// left/right -> char
	// c-left/right -> word left/right
	// a-left/right -> line start/end
	// c-a-left/right -> text start/end
	// home/end -> line start/end
	// c-up/down -> grow/shrink
	// up/down -> row
	// c-home/end -> text start/end
	// c-;/' -> sub word
</script>
